<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Real Estate Reel Generator</title>
  <style>
    :root { --w: 1080; --h: 1920; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background:#0b0d12; color:#e7e9ee; }
    header { padding: 16px 18px; border-bottom: 1px solid rgba(255,255,255,.08); background: rgba(255,255,255,.03); position: sticky; top: 0; }
    h1 { margin: 0; font-size: 16px; font-weight: 700; letter-spacing: .2px; }
    main { display: grid; grid-template-columns: 360px 1fr; gap: 16px; padding: 16px; }
    .panel { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 14px; }
    .panel h2 { margin: 0 0 10px; font-size: 13px; opacity: .9; }
    label { display:block; font-size: 12px; opacity: .9; margin: 10px 0 6px; }
    input, select, button, textarea {
      width: 100%; box-sizing: border-box;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      color: #e7e9ee;
      border-radius: 10px;
      padding: 10px 10px;
      outline: none;
    }
    input[type="file"] { padding: 10px; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    button { cursor:pointer; font-weight: 700; }
    button.primary { background: #6d5efc; border-color: rgba(255,255,255,.18); }
    button:disabled { opacity: .55; cursor:not-allowed; }
    .hint { font-size: 12px; opacity: .75; line-height: 1.4; margin-top: 8px; }
    .previewWrap { display:flex; flex-direction: column; gap: 12px; }
    .stage {
      display:flex; align-items:flex-start; gap: 16px;
      background: rgba(255,255,255,.02);
      border: 1px dashed rgba(255,255,255,.18);
      border-radius: 14px;
      padding: 14px;
    }
    canvas { width: 270px; height: 480px; border-radius: 12px; background:#111; border:1px solid rgba(255,255,255,.12); }
    video { width: 270px; height: 480px; border-radius: 12px; border:1px solid rgba(255,255,255,.12); background:#111; }
    .list { max-height: 260px; overflow:auto; border-top: 1px solid rgba(255,255,255,.08); margin-top: 12px; padding-top: 10px; }
    .thumb { display:flex; gap:10px; align-items:center; padding:8px 0; border-bottom: 1px solid rgba(255,255,255,.06); }
    .thumb img { width: 44px; height: 44px; object-fit: cover; border-radius: 8px; border: 1px solid rgba(255,255,255,.10); }
    .thumb div { font-size: 12px; opacity: .9; overflow:hidden; text-overflow: ellipsis; white-space: nowrap; }
    .pillPreview { display:flex; gap: 8px; align-items:center; margin-top: 10px; font-size: 12px; opacity: .9; }
    .pillDot { width: 10px; height: 10px; border-radius: 99px; background: #2bd576; display:inline-block; }
    a { color: #b7b2ff; text-decoration: none; }
    @media (max-width: 980px){
      main { grid-template-columns: 1fr; }
      canvas, video { width: 216px; height: 384px; }
    }
  </style>
</head>
<body>
<header>
  <h1>Real Estate Reel Generator (blur background template)</h1>
</header>

<main>
  <section class="panel">
    <h2>1) Upload photos</h2>
    <input id="files" type="file" accept="image/*" multiple />
    <div class="hint">
      This makes a 1080×1920 “blurred background + centered photo” slide for each image.
      Exports PNG frames + a video (usually WebM).
    </div>

    <h2 style="margin-top:16px;">2) Overlay text</h2>
    <label>Status</label>
    <select id="status">
      <option value="Түрээс">Түрээс</option>
      <option value="Борлуулах">Борлуулах</option>
      <option value="Зарсан">Зарсан</option>
    </select>

    <div class="row">
      <div>
        <label>Price (line 1)</label>
        <input id="price" placeholder="2,100,000₮ / сар" />
      </div>
      <div>
        <label>Details (line 2)</label>
        <input id="details" placeholder="78m² | 3 өрөө" />
      </div>
    </div>

    <label>Location (line 3)</label>
    <input id="location" placeholder="Яармаг, Tuul River хотхон" />

    <div class="row">
      <div>
        <label>Accent color</label>
        <input id="accent" type="color" value="#6d5efc" />
      </div>
      <div>
        <label>Status color</label>
        <input id="statusColor" type="color" value="#2bd576" />
      </div>
    </div>

    <h2 style="margin-top:16px;">3) Layout controls</h2>
    <div class="row">
      <div>
        <label>Main photo fit</label>
        <select id="fitMode">
          <option value="contain" selected>Contain (no crop)</option>
          <option value="cover">Cover (crop)</option>
        </select>
      </div>
      <div>
        <label>Blur strength</label>
        <input id="blur" type="range" min="0" max="40" value="18" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Slide seconds</label>
        <input id="seconds" type="number" min="1" max="10" value="2" />
      </div>
      <div>
        <label>FPS</label>
        <input id="fps" type="number" min="10" max="60" value="30" />
      </div>
    </div>

    <div class="pillPreview"><span class="pillDot" id="pillDot"></span> <span id="pillText">Status pill preview</span></div>

    <h2 style="margin-top:16px;">4) Export</h2>
    <div class="row">
      <button id="btnFrames">Download PNG frames (ZIP)</button>
      <button id="btnVideo" class="primary">Generate video</button>
    </div>
    <div class="hint" id="exportHint"></div>

    <div class="list" id="list"></div>
  </section>

  <section class="panel previewWrap">
    <h2>Preview</h2>
    <div class="stage">
      <div>
        <div class="hint" style="margin:0 0 8px;">Canvas preview (current slide)</div>
        <canvas id="canvas" width="1080" height="1920"></canvas>
      </div>
      <div>
        <div class="hint" style="margin:0 0 8px;">Exported video preview</div>
        <video id="vid" controls muted playsinline></video>
        <div class="hint">
          If you *need* MP4: GitHub Pages alone won’t reliably encode MP4 in-browser. Use a backend FFmpeg, or accept WebM.
        </div>
      </div>
    </div>
  </section>
</main>

<!-- JSZip for frames ZIP -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(() => {
  const W = 1080, H = 1920;
  const filesEl = document.getElementById('files');
  const listEl  = document.getElementById('list');
  const c = document.getElementById('canvas');
  const ctx = c.getContext('2d');

  const statusEl = document.getElementById('status');
  const priceEl = document.getElementById('price');
  const detailsEl = document.getElementById('details');
  const locationEl = document.getElementById('location');
  const accentEl = document.getElementById('accent');
  const statusColorEl = document.getElementById('statusColor');
  const fitModeEl = document.getElementById('fitMode');
  const blurEl = document.getElementById('blur');
  const secondsEl = document.getElementById('seconds');
  const fpsEl = document.getElementById('fps');

  const pillDot = document.getElementById('pillDot');
  const pillText = document.getElementById('pillText');

  const btnFrames = document.getElementById('btnFrames');
  const btnVideo = document.getElementById('btnVideo');
  const exportHint = document.getElementById('exportHint');
  const vid = document.getElementById('vid');

  /** Loaded images (as HTMLImageElement) */
  let slides = [];
  let currentIndex = 0;

  function setHint(msg){ exportHint.textContent = msg || ""; }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function drawRoundedRect(ctx, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function fitRect(imgW, imgH, boxW, boxH, mode){
    const imgAR = imgW / imgH;
    const boxAR = boxW / boxH;
    let w, h;
    if(mode === 'cover'){
      if(imgAR > boxAR){ h = boxH; w = h * imgAR; }
      else { w = boxW; h = w / imgAR; }
    } else { // contain
      if(imgAR > boxAR){ w = boxW; h = w / imgAR; }
      else { h = boxH; w = h * imgAR; }
    }
    return { w, h, x: (boxW - w)/2, y: (boxH - h)/2 };
  }

  function textShadow(){
    ctx.shadowColor = 'rgba(0,0,0,0.55)';
    ctx.shadowBlur = 18;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 6;
  }
  function clearShadow(){
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }

  function drawSlide(img){
    ctx.clearRect(0,0,W,H);

    // Background: zoomed + blurred
    const blurPx = Number(blurEl.value || 0);
    ctx.save();
    ctx.filter = `blur(${blurPx}px)`;
    const bgFit = fitRect(img.naturalWidth, img.naturalHeight, W, H, 'cover');
    ctx.drawImage(img, bgFit.x, bgFit.y, bgFit.w, bgFit.h);
    ctx.restore();

    // Dark overlay to make text readable
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    ctx.fillRect(0,0,W,H);

    // Main photo frame (centered)
    const pad = 90;
    const frameW = W - pad*2;
    const frameH = H - 540; // leaves space for text block
    const frameX = pad;
    const frameY = 160;

    // Rounded frame + subtle border
    ctx.save();
    drawRoundedRect(ctx, frameX, frameY, frameW, frameH, 44);
    ctx.clip();

    const fm = fitModeEl.value;
    const mainFit = fitRect(img.naturalWidth, img.naturalHeight, frameW, frameH, fm);
    ctx.drawImage(img, frameX + mainFit.x, frameY + mainFit.y, mainFit.w, mainFit.h);

    // Slight vignette inside frame
    const grad = ctx.createLinearGradient(0, frameY, 0, frameY+frameH);
    grad.addColorStop(0, 'rgba(0,0,0,0.00)');
    grad.addColorStop(1, 'rgba(0,0,0,0.20)');
    ctx.fillStyle = grad;
    ctx.fillRect(frameX, frameY, frameW, frameH);
    ctx.restore();

    // Frame stroke
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 4;
    drawRoundedRect(ctx, frameX, frameY, frameW, frameH, 44);
    ctx.stroke();

    // Bottom text block background fade
    const fade = ctx.createLinearGradient(0, H-560, 0, H);
    fade.addColorStop(0, 'rgba(0,0,0,0)');
    fade.addColorStop(1, 'rgba(0,0,0,0.55)');
    ctx.fillStyle = fade;
    ctx.fillRect(0, H-640, W, 640);

    // Status pill
    const status = statusEl.value || "Түрээс";
    const statusColor = statusColorEl.value || "#2bd576";
    const pillPadX = 26;
    const pillPadY = 14;

    ctx.font = '700 52px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    const pillTextW = ctx.measureText(status).width;
    const pillH = 84; // fixed height (consistent for any text)
    const pillW = Math.ceil(pillTextW + pillPadX*2);
    const pillX = 90;
    const pillY = H - 520;

    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    drawRoundedRect(ctx, pillX+6, pillY+10, pillW, pillH, 999);
    ctx.fill();

    ctx.fillStyle = statusColor;
    drawRoundedRect(ctx, pillX, pillY, pillW, pillH, 999);
    ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.16)';
    drawRoundedRect(ctx, pillX, pillY, pillW, pillH, 999);
    ctx.fill();

    ctx.fillStyle = '#0b0d12';
    ctx.textBaseline = 'middle';
    ctx.fillText(status, pillX + pillPadX, pillY + pillH/2);

    // Text overlays
    const accent = accentEl.value || "#6d5efc";

    // Price
    const price = (priceEl.value || "").trim();
    const details = (detailsEl.value || "").trim();
    const location = (locationEl.value || "").trim();

    let textX = 90;
    let y = H - 400;

    // Price line
    if(price){
      textShadow();
      ctx.font = '800 72px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillStyle = '#ffffff';
      ctx.fillText(price, textX, y);
      clearShadow();
      y += 88;
    }

    // Details line
    if(details){
      textShadow();
      ctx.font = '700 56px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.fillText(details, textX, y);
      clearShadow();
      y += 72;
    }

    // Location line with accent bar
    if(location){
      // accent bar
      ctx.fillStyle = accent;
      ctx.globalAlpha = 0.9;
      ctx.fillRect(textX, y+16, 16, 56);
      ctx.globalAlpha = 1;

      textShadow();
      ctx.font = '600 46px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.fillText(location, textX + 28, y+44);
      clearShadow();
    }

    // Tiny footer
    ctx.font = '500 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    ctx.fillText('Generated locally in your browser', 90, H - 80);
  }

  function updatePillPreview(){
    pillDot.style.background = statusColorEl.value;
    pillText.textContent = `Status: ${statusEl.value} (pill height fixed)`;
  }

  async function fileToImage(file){
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.decoding = 'async';
    img.loading = 'eager';
    // Prevent tainting if you later add external images
    img.crossOrigin = 'anonymous';
    await new Promise((res, rej) => {
      img.onload = () => res();
      img.onerror = () => rej(new Error('Failed to load image'));
      img.src = url;
    });
    return { img, url, name: file.name };
  }

  function renderList(){
    listEl.innerHTML = "";
    slides.forEach((s, i) => {
      const row = document.createElement('div');
      row.className = 'thumb';
      const thumb = document.createElement('img');
      thumb.src = s.url;
      const meta = document.createElement('div');
      meta.textContent = `${i+1}. ${s.name}`;
      row.appendChild(thumb);
      row.appendChild(meta);
      row.onclick = () => {
        currentIndex = i;
        drawSlide(slides[currentIndex].img);
      };
      listEl.appendChild(row);
    });
  }

  function canExport(){
    return slides.length > 0;
  }

  async function downloadBlob(blob, filename){
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  async function exportFramesZip(){
    if(!canExport()) return;

    btnFrames.disabled = true;
    btnVideo.disabled = true;
    setHint("Rendering PNG frames and zipping...");

    const zip = new JSZip();
    const folder = zip.folder("frames");
    for(let i=0;i<slides.length;i++){
      drawSlide(slides[i].img);
      const blob = await new Promise(res => c.toBlob(res, 'image/png'));
      folder.file(String(i+1).padStart(3,'0') + ".png", blob);
      setHint(`Rendered frame ${i+1}/${slides.length}`);
      await new Promise(r => setTimeout(r, 0));
    }
    const out = await zip.generateAsync({ type: "blob" });
    await downloadBlob(out, "real_estate_frames.zip");
    setHint("Downloaded: real_estate_frames.zip");

    btnFrames.disabled = false;
    btnVideo.disabled = false;
  }

  function pickRecorderMime(){
    // Try MP4 first (usually fails), then WebM options.
    const candidates = [
      'video/mp4;codecs=h264',
      'video/mp4',
      'video/webm;codecs=vp9',
      'video/webm;codecs=vp8',
      'video/webm'
    ];
    for(const m of candidates){
      if(window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m;
    }
    return '';
  }

  async function exportVideo(){
    if(!canExport()) return;

    const seconds = clamp(Number(secondsEl.value || 2), 1, 10);
    const fps = clamp(Number(fpsEl.value || 30), 10, 60);
    const totalFramesPerSlide = Math.max(1, Math.round(seconds * fps));

    btnFrames.disabled = true;
    btnVideo.disabled = true;

    const mime = pickRecorderMime();
    if(!mime){
      setHint("Your browser doesn't support MediaRecorder export here. Try Chrome/Edge on desktop.");
      btnFrames.disabled = false;
      btnVideo.disabled = false;
      return;
    }

    setHint(`Recording video... (${mime})`);
    // Capture the canvas stream
    const stream = c.captureStream(fps);
    const chunks = [];
    let rec;

    try{
      rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 8_000_000 });
    } catch(e){
      setHint("MediaRecorder failed to start. Browser being browser. Try Chrome/Edge.");
      btnFrames.disabled = false;
      btnVideo.disabled = false;
      return;
    }

    rec.ondataavailable = (e) => { if(e.data && e.data.size) chunks.push(e.data); };

    const stopped = new Promise(res => rec.onstop = res);

    rec.start(200); // collect chunks every 200ms

    // Playback loop: draw each slide for N frames
    for(let i=0;i<slides.length;i++){
      for(let f=0; f<totalFramesPerSlide; f++){
        drawSlide(slides[i].img);
        // small progress update sometimes
        if(f === 0) setHint(`Recording slide ${i+1}/${slides.length}...`);
        await new Promise(r => setTimeout(r, 1000 / fps));
      }
    }

    rec.stop();
    await stopped;

    const blob = new Blob(chunks, { type: mime.split(';')[0] || 'video/webm' });
    const ext = (mime.includes('mp4')) ? 'mp4' : 'webm';
    const filename = `real_estate_reel.${ext}`;

    // Preview in <video>
    const url = URL.createObjectURL(blob);
    vid.src = url;

    await downloadBlob(blob, filename);
    setHint(`Downloaded: ${filename} (If you need MP4 and got WebM, you need FFmpeg server-side.)`);

    btnFrames.disabled = false;
    btnVideo.disabled = false;
  }

  function redraw(){
    updatePillPreview();
    if(slides.length){
      drawSlide(slides[currentIndex].img);
    } else {
      // empty canvas state
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#11131a';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.font = '700 56px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillText('Upload listing photos', 90, 220);
      ctx.font = '500 36px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.fillText('Then export frames or a reel video.', 90, 290);
    }
  }

  // Events
  filesEl.addEventListener('change', async () => {
    const files = [...filesEl.files || []];
    slides = [];
    listEl.innerHTML = "";
    vid.removeAttribute('src');
    vid.load();
    if(!files.length){ redraw(); return; }

    setHint("Loading images...");
    btnFrames.disabled = true;
    btnVideo.disabled = true;

    for(const f of files){
      try{
        const item = await fileToImage(f);
        slides.push(item);
      } catch(e){
        console.error(e);
      }
    }
    currentIndex = 0;
    renderList();
    redraw();
    setHint(`Loaded ${slides.length} image(s). Click thumbnails to preview.`);
    btnFrames.disabled = false;
    btnVideo.disabled = false;
  });

  [statusEl, priceEl, detailsEl, locationEl, accentEl, statusColorEl, fitModeEl, blurEl].forEach(el => {
    el.addEventListener('input', redraw);
    el.addEventListener('change', redraw);
  });

  btnFrames.addEventListener('click', exportFramesZip);
  btnVideo.addEventListener('click', exportVideo);

  // Init
  updatePillPreview();
  redraw();
})();
</script>
</body>
</html>

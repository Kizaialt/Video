<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reel Generator (Real Estate)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; background:#0b0d12; color:#e7e9ee; }
    header { padding: 16px 18px; border-bottom: 1px solid rgba(255,255,255,.08); background: rgba(255,255,255,.03); position: sticky; top: 0; z-index: 5; }
    h1 { margin:0; font-size:16px; font-weight:800; }
    main { display:grid; grid-template-columns: 390px 1fr; gap:16px; padding:16px; }
    .panel { background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:14px; }
    .panel h2 { margin:0 0 10px; font-size:13px; opacity:.9; }
    label { display:block; font-size:12px; opacity:.9; margin:10px 0 6px; }
    input, textarea, select, button {
      width:100%; box-sizing:border-box;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:#e7e9ee;
      border-radius:10px;
      padding:10px;
      outline:none;
    }
    textarea { min-height: 120px; resize: vertical; line-height: 1.35; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    button { cursor:pointer; font-weight:800; }
    button.primary { background:#6d5efc; border-color: rgba(255,255,255,.18); }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .hint { font-size:12px; opacity:.75; line-height:1.4; margin-top:8px; }
    .list { max-height: 260px; overflow:auto; border-top: 1px solid rgba(255,255,255,.08); margin-top: 12px; padding-top: 10px; }
    .thumb { display:flex; gap:10px; align-items:center; padding:8px 0; border-bottom: 1px solid rgba(255,255,255,.06); }
    .thumb img { width:44px; height:44px; object-fit:cover; border-radius:8px; border: 1px solid rgba(255,255,255,.10); }
    .thumb div { font-size:12px; opacity:.9; overflow:hidden; text-overflow: ellipsis; white-space: nowrap; }
    .stage { background: rgba(255,255,255,.02); border: 1px dashed rgba(255,255,255,.18); border-radius:14px; padding:14px; display:flex; gap:14px; align-items:flex-start; flex-wrap: wrap; }
    canvas { width: 324px; height: 576px; border-radius: 12px; background:#111; border:1px solid rgba(255,255,255,.12); }
    video { width: 324px; height: 576px; border-radius: 12px; background:#111; border:1px solid rgba(255,255,255,.12); }
    @media (max-width: 980px){
      main { grid-template-columns: 1fr; }
      canvas, video { width: 270px; height: 480px; }
    }
  </style>
</head>
<body>
<header>
  <h1>Reel Generator (1080√ó1920 video)</h1>
</header>

<main>
  <section class="panel">
    <h2>1) Upload photos</h2>
    <input id="files" type="file" accept="image/*" multiple />
    <div class="hint">
      Generates a single Reel video. Add audio later in IG/TikTok.
      Output is usually WebM (browser limitation), sometimes MP4.
    </div>

    <h2 style="margin-top:16px;">2) Text + style</h2>

    <label>Status (pill)</label>
    <select id="status">
      <option value="–¢“Ø—Ä—ç—ç—Å">–¢“Ø—Ä—ç—ç—Å</option>
      <option value="–ë–æ—Ä–ª—É—É–ª–∞—Ö">–ë–æ—Ä–ª—É—É–ª–∞—Ö</option>
      <option value="–ó–∞—Ä—Å–∞–Ω">–ó–∞—Ä—Å–∞–Ω</option>
    </select>

    <label>Bottom text block</label>
    <textarea id="mainText" placeholder="üîë –ë–ó–î-–∏–π–Ω —É—Ä–¥ ‚ÄúBayanzurkhApartment‚Äù —Ö–æ—Ç—Ö–æ–Ω–¥
–∑–æ—Ö–∏–æ–Ω –±–∞–π–≥—É—É–ª–∞–ª—Ç —Å–∞–π—Ç–∞–π 3 ”©—Ä”©”© –æ—Ä–æ–Ω —Å—É—É—Ü —Ö—É–¥–∞–ª–¥–∞–Ω–∞.

üìû 8811-6639
üìê 66.8m¬≤
üõèÔ∏è 3 ”©—Ä”©”©
üè¢ 16/2 –¥–∞–≤—Ö–∞—Ä—Ç"></textarea>

    <div class="row">
      <div>
        <label>Status color</label>
        <input id="statusColor" type="color" value="#2bd576" />
      </div>
      <div>
        <label>Blur strength</label>
        <input id="blur" type="range" min="0" max="40" value="18" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Hero position</label>
        <select id="heroPos">
          <option value="upper" selected>Upper third</option>
          <option value="top">Near top</option>
          <option value="center">Center</option>
        </select>
      </div>
      <div>
        <label>Hero fit</label>
        <select id="fitMode">
          <option value="cover" selected>Cover (best)</option>
          <option value="contain">Contain</option>
        </select>
      </div>
    </div>

    <h2 style="margin-top:16px;">3) Video settings</h2>

    <div class="row">
      <div>
        <label>Seconds per photo</label>
        <input id="seconds" type="number" min="1" max="10" value="2" />
      </div>
      <div>
        <label>FPS</label>
        <input id="fps" type="number" min="10" max="60" value="30" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Hero motion</label>
        <select id="motion">
          <option value="none">None (static)</option>
          <option value="photo" selected>Photo only (recommended)</option>
        </select>
      </div>
      <div>
        <label>Zoom strength</label>
        <input id="zoom" type="range" min="0" max="10" value="4" />
      </div>
    </div>

    <h2 style="margin-top:16px;">4) Export</h2>
    <div class="row">
      <button id="btnPreview">Redraw preview</button>
      <button id="btnVideo" class="primary">Generate Reel Video</button>
    </div>
    <div class="hint" id="hint"></div>

    <div class="list" id="list"></div>
  </section>

  <section class="panel">
    <h2>Preview</h2>
    <div class="stage">
      <div>
        <div class="hint" style="margin:0 0 8px;">Canvas (current slide)</div>
        <canvas id="canvas" width="1080" height="1920"></canvas>
      </div>
      <div>
        <div class="hint" style="margin:0 0 8px;">Generated video preview</div>
        <video id="vid" controls muted playsinline></video>
        <div class="hint">
          If IG refuses WebM on your device, convert once in CapCut to MP4.
        </div>
      </div>
    </div>
  </section>
</main>

<script>
(() => {
  const W = 1080, H = 1920;

  const filesEl = document.getElementById('files');
  const listEl = document.getElementById('list');
  const c = document.getElementById('canvas');
  const ctx = c.getContext('2d');

  const statusEl = document.getElementById('status');
  const mainTextEl = document.getElementById('mainText');
  const statusColorEl = document.getElementById('statusColor');
  const blurEl = document.getElementById('blur');
  const heroPosEl = document.getElementById('heroPos');
  const fitModeEl = document.getElementById('fitMode');

  const secondsEl = document.getElementById('seconds');
  const fpsEl = document.getElementById('fps');
  const motionEl = document.getElementById('motion');
  const zoomEl = document.getElementById('zoom');

  const btnPreview = document.getElementById('btnPreview');
  const btnVideo = document.getElementById('btnVideo');
  const hintEl = document.getElementById('hint');
  const vid = document.getElementById('vid');

  let slides = [];
  let currentIndex = 0;

  function hint(msg){ hintEl.textContent = msg || ""; }

  function fitRect(imgW, imgH, boxW, boxH, mode){
    const imgAR = imgW / imgH;
    const boxAR = boxW / boxH;
    let w, h;
    if(mode === 'cover'){
      if(imgAR > boxAR){ h = boxH; w = h * imgAR; }
      else { w = boxW; h = w / imgAR; }
    } else {
      if(imgAR > boxAR){ w = boxW; h = w / imgAR; }
      else { h = boxH; w = h * imgAR; }
    }
    return { w, h, x:(boxW-w)/2, y:(boxH-h)/2 };
  }

  function drawRoundedRect(ctx, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function textShadow(){
    ctx.shadowColor = 'rgba(0,0,0,0.55)';
    ctx.shadowBlur = 18;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 6;
  }
  function clearShadow(){
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }

  function drawMultiline(text, x, y, maxWidth, lineHeight){
    const lines = (text || "").split(/\n/);
    for(const line of lines){
      const words = line.split(/\s+/);
      let cur = "";
      for(const w of words){
        const test = cur ? cur + " " + w : w;
        if(ctx.measureText(test).width > maxWidth && cur){
          ctx.fillText(cur, x, y);
          y += lineHeight;
          cur = w;
        } else {
          cur = test;
        }
      }
      if(cur){
        ctx.fillText(cur, x, y);
        y += lineHeight;
      } else {
        y += lineHeight;
      }
    }
    return y;
  }

  function getHeroY(heroH){
    const mode = heroPosEl.value;
    if(mode === "top") return 110;
    if(mode === "center") return Math.round(H/2 - heroH/2 - 80);
    return 170;
  }

  // Draw stable background + stable text. We will draw HERO separately (optionally moving).
  function drawSlideBase(img){
    ctx.clearRect(0,0,W,H);

    const blurPx = Number(blurEl.value || 18);

    // Background blur cover
    ctx.save();
    ctx.filter = `blur(${blurPx}px)`;
    const bgFit = fitRect(img.naturalWidth, img.naturalHeight, W, H, 'cover');
    ctx.drawImage(img, bgFit.x, bgFit.y, bgFit.w, bgFit.h);
    ctx.restore();

    // Contrast overlay
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.fillRect(0,0,W,H);
  }

  // Draw hero with optional motion, then draw bottom panel + pinned pill + text.
  function drawSlidePhotoPinnedPill(img, t){
    // t: 0..1 for motion. If no motion, pass 0.
    drawSlideBase(img);

    const heroW = W;
    const heroH = Math.round(W * 9 / 16);
    const heroX = 0;
    const heroY = getHeroY(heroH);

    // HERO base cover fit inside hero box
    const baseFit = fitRect(img.naturalWidth, img.naturalHeight, heroW, heroH, fitModeEl.value || 'cover');

    // Motion (photo only)
    const motion = motionEl.value;
    const strength = Number(zoomEl.value || 4) / 100; // 0..0.10
    const useMotion = (motion === 'photo');

    const z = useMotion ? (1 + strength * t) : 1;
    const panX = useMotion ? ((t - 0.5) * 26) : 0;
    const panY = useMotion ? ((0.5 - t) * 10) : 0;

    const drawW = baseFit.w * z;
    const drawH = baseFit.h * z;

    // Center-correct then pan
    const dx = heroX + baseFit.x - (drawW - baseFit.w)/2 + panX;
    const dy = heroY + baseFit.y - (drawH - baseFit.h)/2 + panY;

    // Draw hero sharp
    ctx.save();
    ctx.filter = 'none';
    ctx.drawImage(img, dx, dy, drawW, drawH);

    // Hero fade edges
    const heroFade = ctx.createLinearGradient(0, heroY, 0, heroY + heroH);
    heroFade.addColorStop(0.00, 'rgba(0,0,0,0.18)');
    heroFade.addColorStop(0.15, 'rgba(0,0,0,0.00)');
    heroFade.addColorStop(0.85, 'rgba(0,0,0,0.00)');
    heroFade.addColorStop(1.00, 'rgba(0,0,0,0.18)');
    ctx.fillStyle = heroFade;
    ctx.fillRect(heroX, heroY, heroW, heroH);
    ctx.restore();

    // Bottom text zone starts BELOW hero, but pill will overlap hero bottom edge
    const panelTop = heroY + heroH + 40;
    const padX = 70;

    const panelGrad = ctx.createLinearGradient(0, panelTop - 120, 0, H);
    panelGrad.addColorStop(0, 'rgba(0,0,0,0.00)');
    panelGrad.addColorStop(1, 'rgba(0,0,0,0.62)');
    ctx.fillStyle = panelGrad;
    ctx.fillRect(0, panelTop - 120, W, H - (panelTop - 120));

    // ==== PILL pinned at hero bottom edge (half in, half out) ====
    const status = (statusEl.value || "–¢“Ø—Ä—ç—ç—Å").trim();
    const statusColor = statusColorEl.value || "#2bd576";

    ctx.font = '800 40px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    const pillTextW = ctx.measureText(status).width;
    const pillPadX = 22;
    const pillH = 70;
    const pillW = Math.ceil(pillTextW + pillPadX*2);

    const pillX = padX;

    // This is the key line: place pill so its center sits on hero bottom edge
    // => half inside photo, half outside
    const pillY = Math.round(heroY + heroH - pillH/2);

    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    drawRoundedRect(ctx, pillX+6, pillY+10, pillW, pillH, 999);
    ctx.fill();

    // pill
    ctx.fillStyle = statusColor;
    drawRoundedRect(ctx, pillX, pillY, pillW, pillH, 999);
    ctx.fill();

    // pill text
    ctx.fillStyle = 'rgba(0,0,0,0.72)';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'left';
    ctx.fillText(status, pillX + pillPadX, pillY + pillH/2);

    // ==== Bottom text block ====
    // Start text a bit below pill so it doesn't clash
    const text = (mainTextEl.value || "").trim();
    let y = Math.max(panelTop + 20, pillY + pillH + 34);

    textShadow();
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.font = '700 40px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    drawMultiline(text, padX, y, W - padX*2, 54);
    clearShadow();
  }

  async function fileToImage(file){
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.decoding = 'async';
    img.loading = 'eager';
    await new Promise((res, rej) => {
      img.onload = () => res();
      img.onerror = () => rej(new Error('Failed to load image'));
      img.src = url;
    });
    return { img, url, name: file.name };
  }

  function renderList(){
    listEl.innerHTML = "";
    slides.forEach((s, i) => {
      const row = document.createElement('div');
      row.className = 'thumb';
      const thumb = document.createElement('img');
      thumb.src = s.url;
      const meta = document.createElement('div');
      meta.textContent = `${i+1}. ${s.name}`;
      row.appendChild(thumb);
      row.appendChild(meta);
      row.onclick = () => { currentIndex = i; redraw(); };
      listEl.appendChild(row);
    });
  }

  function redraw(){
    if(slides.length){
      drawSlidePhotoPinnedPill(slides[currentIndex].img, 0);
    } else {
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#11131a';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.font = '800 56px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillText('Upload listing photos', 90, 220);
      ctx.font = '500 36px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.fillText('Then generate a Reel video.', 90, 290);
    }
  }

  async function downloadBlob(blob, filename){
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function pickRecorderMime(){
    const candidates = [
      'video/mp4;codecs=h264',
      'video/mp4',
      'video/webm;codecs=vp9',
      'video/webm;codecs=vp8',
      'video/webm'
    ];
    for(const m of candidates){
      if(window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m;
    }
    return '';
  }

  async function exportVideo(){
    if(!slides.length){
      hint("No photos. Upload first.");
      return;
    }

    const seconds = Math.max(1, Math.min(10, Number(secondsEl.value || 2)));
    const fps = Math.max(10, Math.min(60, Number(fpsEl.value || 30)));
    const framesPerSlide = Math.max(1, Math.round(seconds * fps));

    btnVideo.disabled = true;
    btnPreview.disabled = true;

    const mime = pickRecorderMime();
    if(!mime){
      hint("MediaRecorder not supported. Use Chrome/Edge desktop.");
      btnVideo.disabled = false;
      btnPreview.disabled = false;
      return;
    }

    hint(`Recording... (${mime})`);

    const stream = c.captureStream(fps);
    const chunks = [];
    let rec;

    try{
      rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 8_000_000 });
    } catch(e){
      hint("MediaRecorder failed to start. Try Chrome/Edge.");
      btnVideo.disabled = false;
      btnPreview.disabled = false;
      return;
    }

    rec.ondataavailable = (e) => { if(e.data && e.data.size) chunks.push(e.data); };
    const stopped = new Promise(res => rec.onstop = res);

    rec.start(200);

    for(let i=0; i<slides.length; i++){
      hint(`Recording slide ${i+1}/${slides.length}...`);
      for(let f=0; f<framesPerSlide; f++){
        const t = f / framesPerSlide; // 0..1
        drawSlidePhotoPinnedPill(slides[i].img, t);
        await new Promise(r => setTimeout(r, 1000 / fps));
      }
    }

    rec.stop();
    await stopped;

    const type = mime.split(';')[0] || 'video/webm';
    const blob = new Blob(chunks, { type });
    const ext = mime.includes('mp4') ? 'mp4' : 'webm';
    const filename = `reel_${W}x${H}.${ext}`;

    const url = URL.createObjectURL(blob);
    vid.src = url;

    await downloadBlob(blob, filename);
    hint(`Downloaded: ${filename}`);

    btnVideo.disabled = false;
    btnPreview.disabled = false;
  }

  // Events
  filesEl.addEventListener('change', async () => {
    const files = [...(filesEl.files || [])];
    slides = [];
    listEl.innerHTML = "";
    vid.removeAttribute('src');
    vid.load();

    if(!files.length){ redraw(); return; }

    hint("Loading images...");
    btnVideo.disabled = true;
    btnPreview.disabled = true;

    for(const f of files){
      try { slides.push(await fileToImage(f)); }
      catch(e){ console.error(e); }
    }

    currentIndex = 0;
    renderList();
    redraw();

    hint(`Loaded ${slides.length} image(s). Click a thumbnail to preview.`);
    btnVideo.disabled = false;
    btnPreview.disabled = false;
  });

  btnPreview.addEventListener('click', redraw);
  btnVideo.addEventListener('click', exportVideo);

  [statusEl, mainTextEl, statusColorEl, blurEl, heroPosEl, fitModeEl, secondsEl, fpsEl, motionEl, zoomEl].forEach(el => {
    el.addEventListener('input', redraw);
    el.addEventListener('change', redraw);
  });

  redraw();
})();
</script>
</body>
</html>

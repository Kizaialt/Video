<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Batch Watermark Tool</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;600;700&display=swap" rel="stylesheet">

<style>
:root { color-scheme: dark; }
* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background:#0f1115;
  color:#eaeef4;
}

.wrap { max-width:1100px; margin:28px auto; padding:0 16px; }
.grid { display:grid; grid-template-columns:360px 1fr; gap:16px; }
@media (max-width:980px){ .grid{ grid-template-columns:1fr; } }

.card {
  background:#141826;
  border:1px solid #222940;
  border-radius:14px;
  padding:16px;
}

h1 { margin:0 0 10px; font-size:22px; }
h2 { margin:0 0 10px; font-size:16px; opacity:.9; }

label { display:block; margin:10px 0 6px; font-size:12px; opacity:.9; }

input[type="file"],
select,
input[type="number"],
input[type="range"] {
  width:100%;
  padding:10px;
  background:#0f1320;
  border:1px solid #2a3147;
  color:#eaeef4;
  border-radius:10px;
  outline:none;
}

.row { display:grid; grid-template-columns:1fr 1fr; gap:10px; }

.btns {
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:12px;
}

button {
  background:#7c5cff;
  color:#fff;
  border:0;
  padding:10px 12px;
  border-radius:12px;
  font-weight:700;
  cursor:pointer;
}

button.secondary { background:#2a3350; }
button:disabled { opacity:.55; cursor:not-allowed; }

.note { font-size:12px; opacity:.8; margin-top:8px; line-height:1.35; }

.gallery {
  display:grid;
  grid-template-columns:repeat(auto-fill, minmax(220px,1fr));
  gap:12px;
}

.thumb {
  background:#0b0f1c;
  border:1px solid #222940;
  border-radius:12px;
  overflow:hidden;
  aspect-ratio:1/1;
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
}

.thumb img { max-width:100%; max-height:100%; }

.cap {
  position:absolute;
  left:8px;
  bottom:8px;
  font-size:11px;
  background:rgba(0,0,0,.45);
  padding:5px 8px;
  border-radius:8px;
}

.hr {
  height: 1px;
  background: rgba(255,255,255,0.08);
  margin: 12px 0;
}
</style>
</head>

<body>
<div class="wrap">
  <div class="grid">

    <div class="card">
      <h1>Batch Watermark</h1>

      <div class="note" id="deviceNote"></div>

      <label>Photos (multiple)</label>
      <input id="photos" type="file" accept="image/*" multiple />

      <label>Logo variation</label>
      <select id="wmPick"></select>
      <div id="wmStatus" class="note">Loading watermark‚Ä¶</div>

      <div class="hr"></div>

      <div class="row">
        <div>
          <label>Placement</label>
          <select id="pos">
            <option value="bottom-center">Bottom center</option>
            <option value="bottom-right">Bottom right</option>
            <option value="bottom-left">Bottom left</option>
            <option value="top-right">Top right</option>
            <option value="top-left">Top left</option>
            <option value="center">Center</option>
            <option value="tiled">Tiled</option>
          </select>
        </div>
        <div>
          <label>Size (% of width)</label>
          <input id="scale" type="number" value="15" min="2" max="80" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Opacity</label>
          <div style="display:flex;align-items:center;gap:10px;">
            <input id="opacity" type="range" value="100" min="0" max="100" />
            <span id="opacityVal" style="min-width:40px;font-size:12px;">100%</span>
          </div>
        </div>
        <div>
          <label>Padding (px)</label>
          <input id="pad" type="number" value="50" min="0" max="300" />
        </div>
      </div>

      <div class="btns">
        <button id="previewBtn" class="secondary" disabled>Preview First</button>
        <button id="processBtn" disabled>Process All</button>
        <button id="clearBtn" class="secondary">Clear</button>
      </div>

      <div class="note">
        Tip: On iPhone/iPad this downloads a single ZIP (Safari blocks multi-download).
      </div>
    </div>

    <div class="card">
      <h2>Preview</h2>
      <div id="gallery" class="gallery"></div>
      <div id="status" class="note"></div>
    </div>

  </div>
</div>

<!-- JSZip (needed for iPhone/iPad Safari single ZIP download) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(() => {
const $ = s => document.querySelector(s);

/* üî¥ REPLACE THESE URLS üî¥ */
const WATERMARKS = [
  { id:"wm1", name:"Logo 1", url:"REPLACE_URL_1" },
  { id:"wm2", name:"Logo 2", url:"REPLACE_URL_2" },
  { id:"wm3", name:"Logo 3", url:"REPLACE_URL_3" }
];

const photosEl = $('#photos');
const wmPick = $('#wmPick');
const wmStatus = $('#wmStatus');
const posEl = $('#pos');
const scaleEl = $('#scale');
const opacityEl = $('#opacity');
const opacityVal = $('#opacityVal');
const padEl = $('#pad');
const previewBtn = $('#previewBtn');
const processBtn = $('#processBtn');
const clearBtn = $('#clearBtn');
const gallery = $('#gallery');
const statusEl = $('#status');
const deviceNote = $('#deviceNote');

let photoFiles = [];
let watermarkCache = new Map();
let activeWM = WATERMARKS[0].id;

// ---- iOS Safari detection (zip mode)
const ua = navigator.userAgent || "";
const isIOS = /iP(hone|ad|od)/.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
const isSafari = /^((?!chrome|android|crios|fxios|edgios).)*safari/i.test(ua);
const useZip = isIOS && isSafari;

deviceNote.textContent = useZip
  ? "üì± iPhone/iPad Safari: will download ONE ZIP (Safari blocks multi-download)."
  : "üñ•Ô∏è Desktop/Android: will download each image directly (no ZIP).";

// ---- opacity number display
opacityVal.textContent = opacityEl.value + '%';
opacityEl.addEventListener('input', () => {
  opacityVal.textContent = opacityEl.value + '%';
});

// ---- helpers
function downloadBlob(blob, name) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function fileToImage(file) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
    img.onerror = (e) => { URL.revokeObjectURL(url); reject(e); };
    img.src = url;
  });
}

function place(pos, W, H, wW, wH, p) {
  const m = {
    "bottom-center":[(W-wW)/2, H-wH-p],
    "bottom-right":[W-wW-p,   H-wH-p],
    "bottom-left":[p,         H-wH-p],
    "top-right":[W-wW-p,      p],
    "top-left":[p,            p],
    "center":[(W-wW)/2,       (H-wH)/2]
  };
  return m[pos] || m["bottom-center"];
}

function drawTiled(ctx, wm, W, H, cellW, cellH, opacity) {
  ctx.save();
  ctx.globalAlpha = opacity;
  const xStep = Math.max(1, Math.round(cellW * 1.25));
  const yStep = Math.max(1, Math.round(cellH * 1.25));
  for (let y = -cellH; y < H + cellH; y += yStep) {
    for (let x = -cellW; x < W + cellW; x += xStep) {
      ctx.drawImage(wm, x, y, cellW, cellH);
    }
  }
  ctx.restore();
}

async function renderOne(img, wm) {
  const W = img.naturalWidth || img.width;
  const H = img.naturalHeight || img.height;

  const c = document.createElement('canvas');
  c.width = W; c.height = H;
  const ctx = c.getContext('2d');

  // Base photo
  ctx.drawImage(img, 0, 0, W, H);

  // Watermark sizing
  const scale = Number(scaleEl.value) / 100;       // 0.15 default
  const pad = Number(padEl.value);
  const opacity = Number(opacityEl.value) / 100;   // 1.0 default

  const wmW = wm.naturalWidth || wm.width;
  const wmH = wm.naturalHeight || wm.height;
  const targetW = W * scale;
  const targetH = targetW * (wmH / wmW);

  if (posEl.value === "tiled") {
    drawTiled(ctx, wm, W, H, targetW, targetH, opacity);
  } else {
    const [x, y] = place(posEl.value, W, H, targetW, targetH, pad);
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.drawImage(wm, x, y, targetW, targetH);
    ctx.restore();
  }

  return new Promise(resolve => c.toBlob(b => resolve(b), 'image/jpeg', 0.92));
}

function showThumb(name, blob) {
  const d = document.createElement('div');
  d.className = "thumb";
  const i = new Image();
  i.src = URL.createObjectURL(blob);
  const c = document.createElement('div');
  c.className = "cap";
  c.textContent = name;
  d.append(i, c);
  gallery.appendChild(d);
}

function setButtonsEnabled() {
  const ready = photoFiles.length > 0 && watermarkCache.has(activeWM);
  previewBtn.disabled = !ready;
  processBtn.disabled = !ready;
}

function populateDropdown() {
  wmPick.innerHTML = WATERMARKS.map(w => `<option value="${w.id}">${w.name}</option>`).join("");
  wmPick.value = activeWM;
}

function loadWM(id) {
  const w = WATERMARKS.find(x => x.id === id);
  activeWM = id;

  if (!w || !w.url || w.url.startsWith("REPLACE_")) {
    wmStatus.textContent = "‚ùå Put real URLs into WATERMARKS[] first.";
    setButtonsEnabled();
    return;
  }

  if (watermarkCache.has(id)) {
    wmStatus.textContent = "‚úÖ Loaded: " + w.name;
    setButtonsEnabled();
    return;
  }

  wmStatus.textContent = "Loading: " + w.name + "‚Ä¶";
  const img = new Image();
  img.crossOrigin = "anonymous"; // required when drawing remote images onto canvas
  img.onload = () => {
    watermarkCache.set(id, img);
    wmStatus.textContent = "‚úÖ Loaded: " + w.name;
    setButtonsEnabled();
  };
  img.onerror = () => {
    wmStatus.textContent = "‚ùå Failed to load watermark (URL must be public, CORS-friendly). GitHub Pages is safest.";
    setButtonsEnabled();
  };
  img.src = w.url;
}

// ---- actions
async function preview() {
  gallery.innerHTML = "";
  statusEl.textContent = "Rendering preview‚Ä¶";

  try {
    const wm = watermarkCache.get(activeWM);
    const img = await fileToImage(photoFiles[0]);
    const blob = await renderOne(img, wm);

    showThumb("PREVIEW (no download)", blob);
    statusEl.textContent = "Preview ready.";
  } catch (e) {
    console.error(e);
    statusEl.textContent = "Preview failed.";
  }
}

async function processAll() {
  gallery.innerHTML = "";
  statusEl.textContent = useZip ? "Processing ‚Üí building ZIP‚Ä¶" : "Processing ‚Üí downloading‚Ä¶";

  const wm = watermarkCache.get(activeWM);
  if (!wm || photoFiles.length === 0) return;

  if (useZip) {
    // iPhone/iPad Safari: single ZIP
    const zip = new JSZip();
    const folder = zip.folder("watermarked") || zip;

    for (let i = 0; i < photoFiles.length; i++) {
      const f = photoFiles[i];
      const img = await fileToImage(f);
      const blob = await renderOne(img, wm);

      const outName = f.name.replace(/\.(jpg|jpeg|png|webp|gif|bmp|tif|tiff)$/i, '') + `_wm_${activeWM}.jpg`;
      folder.file(outName, blob);

      showThumb(outName, blob);
      statusEl.textContent = `Processed ${i+1} / ${photoFiles.length} (adding to ZIP)`;
      await new Promise(r => setTimeout(r, 50));
    }

    statusEl.textContent = "Creating ZIP‚Ä¶";
    const zipBlob = await zip.generateAsync({ type: "blob" });

    const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    downloadBlob(zipBlob, `watermarked-${activeWM}-${ts}.zip`);
    statusEl.textContent = "Done. ZIP downloaded.";

  } else {
    // Desktop/Android: direct downloads
    for (let i = 0; i < photoFiles.length; i++) {
      const f = photoFiles[i];
      const img = await fileToImage(f);
      const blob = await renderOne(img, wm);

      const outName = f.name.replace(/\.(jpg|jpeg|png|webp|gif|bmp|tif|tiff)$/i, '') + `_wm_${activeWM}.jpg`;
      downloadBlob(blob, outName);
      showThumb(outName, blob);

      statusEl.textContent = `Processed ${i+1} / ${photoFiles.length} (downloaded)`;
      await new Promise(r => setTimeout(r, 120)); // helps browsers not block
    }
    statusEl.textContent = "Done. Files downloaded.";
  }
}

function clearAll() {
  photoFiles = [];
  photosEl.value = "";
  gallery.innerHTML = "";
  statusEl.textContent = "";
  setButtonsEnabled();
}

// ---- events
photosEl.addEventListener('change', (e) => {
  photoFiles = Array.from(e.target.files || []);
  setButtonsEnabled();
});

wmPick.addEventListener('change', (e) => {
  loadWM(e.target.value);
});

previewBtn.addEventListener('click', preview);
processBtn.addEventListener('click', processAll);
clearBtn.addEventListener('click', clearAll);

// ---- init
populateDropdown();
loadWM(activeWM);
setButtonsEnabled();

})();
</script>
</body>
</html>
